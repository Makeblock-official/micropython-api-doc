[Micropython]TPYBoard v10x 教程5 LED-按键手册
=======================================================

原创版权归山东萝卜科技有限公司所有,转载必须以链接形式注明作者和原始出处。

点亮LED实验
-------------------------------

通过前面的python入门和有关pyb的介绍，相信你已经很想通过pyb来做一些东西了。那么本篇文章就带大家做一个点亮LED的pyb入门小实验——点亮LED。

步骤一：连接pyb开发板

步骤二：成功连接pyb开发板后，使用编辑器打开tpyboard里面的main.py文件，输入以下代码：
::

    import pyb
    Led2=pyb.LED(2)
    Led2.on()
            
import pyb，引用pyb封装的类库，实例化一个LED对象命名为led2，LED对象的唯一参数是1-4之间的数字，分别对应开发板上的LED1、LED2、LED3和LED4。然后调用on()函数来点亮LED2。

pyb.LED类的函数有：LED.on()亮灯，LED.off()关灯，LED.toggle() 与LED现在的状态对调，LED.intensity([value])设置LED亮度，value是亮度值，0-255，0是关，255最亮（仅LED3和LED4支持）

步骤三：输入代码后保存文件，pyb上的LED1（标有LED标示的LED）亮起大约5秒后熄灭，这是因为开发板正在将我们修改的内容写入到FLASH中。如果使用TF卡的话，将不会出现这种情况，因为TF卡的写入速度快。为了运行我们新写的脚本，需要将pyb进行复位操作，只要按下开发板上标注的RST按键即可。

**同学们可尝试使用Pyb.LED类的其他函数，实现流水灯、LED4由亮变暗的小实验**
 
按键控制LED实验
---------------------------------

pyb上有两个按键，分别是USR和RST，上一篇【点亮LED】的实验中已介绍RST是复位按键，相当于执行对pyb断电后重新上电的操作。本篇将介绍通过USR用户按键控制LED的亮灭实验。

按键控制LED亮灭
------------------------------

步骤一：连接pyb开发板，使用编辑器打开tpyboard里面的main.py文件，输入以下代码
::

    import pyb
    sw=pyb.Switch()
    led=pyb.LED(1)
    led3=pyb.LED(3)
    while True:
        sw_state=sw()
        if sw_state:
            led.on()
            led3.off()
        else:
            led.off()
            led3.on()
                
实例化一个Switch对象命名为sw，定义两个LED灯，通过LED的亮灭来表示按键的状态（按下或未按下）。sw()函数获取按键当前状态，按下返回True，反之False。当按键按下时，LED1亮起、LED3熄灭。

步骤二：按下RST按键，查看运行效果。

按键回调函数
-------------------------------

按键回调函数：sw.callback()函数。该函数会在按键按下会执行一些创建的代码，且使用一个中断。我们在main.py输入一下代码：
::

    import pyb
    sw=pyb.Switch()
    sw.callback(lambda:pyb.LED(1).toggle())
        
以上例程实现按键每次按下翻转LED1的状态，并且能打断pyb开发板上的任何程序，属于一种异步中断。
其实，你还可以传递不带参数的函数作为参数给按键回调函数使用，上面的功能我们还可以通过以下形式实现同样的效果：
::

    import pyb
    sw=pyb.Switch()
    led=pyb.LED(1)
    def test():
        led.toggle()
    sw.callback(test)
        
如果你不想使用按键回调函数，可以关闭按键回调，只需将函数的参数设置为None即可。

::

    sw.callback(None)
    
中断的原理细节
-------------------------------------------------

现在谈谈按键回调函数发生时的细节。当你调用了含有 sw.callback( )的函数时，按键将在其连接引脚产生一个边沿触发（下降沿）外部中断。这意味着芯片将监听该引脚的任何状态变换，且如下事情会发生：

1.当按键被按下时引脚将发生改变（电平由低到高？），芯片处理器将记录这种变化；

2.处理器完成当前机器指令，退出执行状态并保存当前的状态（将寄存器的内容推入栈中）。这将停止当前运行的任何代码，例如正在执行着的 python 脚本；

3.芯片开始执行与按键相关的特定外部中断触发处理。该处理指向你在 sw.callback( )函数中指定的函数功能并执行之；

4.直到回调函数执行完毕，控制主权将回到中断处理手上；

5.按键中断处理将返回，芯片处理器确认记录该中断被执行过；

6.芯片调回步骤 2 的状态；

7.继续执行开始时的代码，除了短暂的暂停，这部分代码看起来似乎没有被打断过。

当同一时间多个中断同时发生上述的过程将复杂得多。这种情况下拥有最高优先级别的中断将被首先执行，其他的中断按各自的优先级数序执行。按键中断的优先级最低。


更多资料请参考：`<http://docs.micropython.org/en/latest/tpyboard/>`_